<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Lips-songs</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

:root {
  --bg: #0a0a0a;
  --card: #141414;
  --card2: #1c1c1c;
  --accent: #ff4081;
  --accent2: #7c4dff;
  --text: #ffffff;
  --text2: #a0a0a0;
  --text3: #555555;
  --green: #4caf50;
  --red: #f44336;
  --safe-bottom: env(safe-area-inset-bottom, 0px);
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  touch-action: pan-y;
  -webkit-font-smoothing: antialiased;
}

::-webkit-scrollbar { width: 0; height: 0; }

#splash {
  position: fixed;
  inset: 0;
  z-index: 1000;
  background: var(--bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  padding: 32px;
  transition: opacity 0.6s ease, transform 0.6s ease;
}
#splash.hide {
  opacity: 0;
  transform: scale(0.95);
  pointer-events: none;
}

.splash-title {
  font-size: 42px;
  font-weight: 800;
  background: linear-gradient(135deg, var(--accent), var(--accent2), #00bcd4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  opacity: 0;
  transform: translateY(20px);
  animation: fadeInUp 0.8s ease forwards;
}

.splash-card {
  background: var(--card);
  border-radius: 16px;
  padding: 20px 24px;
  max-width: 320px;
  width: 100%;
  opacity: 0;
  transform: translateY(20px);
  animation: fadeInUp 0.8s ease 0.3s forwards;
  border: 1px solid rgba(255,255,255,0.04);
}
.splash-card h3 { font-size: 15px; margin-bottom: 10px; color: var(--accent); }
.splash-card ul { list-style: none; font-size: 13px; color: var(--text2); line-height: 1.8; }
.splash-card ul li::before { content: '> '; color: var(--accent2); font-weight: 700; }

.status-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--text2);
  opacity: 0;
  animation: fadeInUp 0.8s ease 0.5s forwards;
  transform: translateY(20px);
}
.status-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--green);
  animation: pulse 2s ease infinite;
}
.status-dot.offline { background: var(--red); animation: none; }

.splash-btn {
  margin-top: 8px;
  padding: 14px 48px;
  border: none;
  border-radius: 50px;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: white;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  opacity: 0;
  transform: translateY(20px);
  animation: fadeInUp 0.8s ease 0.7s forwards;
  transition: transform 0.15s ease;
}
.splash-btn:active { transform: scale(0.93) translateY(0) !important; }

#app {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
}
#app.show { opacity: 1; pointer-events: all; }

#tabs-container { flex: 1; position: relative; overflow: hidden; }

#tabs-wrapper {
  display: flex;
  width: 400%;
  height: 100%;
  will-change: transform;
  transition: transform 0.38s cubic-bezier(0.22, 0.68, 0.32, 1);
}

.tab-page {
  width: 25%;
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.tab-header {
  flex-shrink: 0;
  padding: 16px 16px 0 16px;
  background: var(--bg);
  z-index: 10;
  position: relative;
}
.tab-header::after {
  content: '';
  position: absolute;
  bottom: -16px;
  left: 0; right: 0;
  height: 16px;
  background: linear-gradient(to bottom, var(--bg), transparent);
  pointer-events: none;
  z-index: 10;
}

.page-title {
  font-size: 28px;
  font-weight: 800;
  margin-bottom: 12px;
  letter-spacing: -0.5px;
}

.search-box { position: relative; margin-bottom: 12px; }
.search-box input {
  width: 100%;
  padding: 12px 16px 12px 42px;
  border: 1px solid rgba(255,255,255,0.04);
  border-radius: 12px;
  background: var(--card);
  color: var(--text);
  font-size: 14px;
  outline: none;
  user-select: text;
  transition: background 0.2s, border-color 0.2s;
}
.search-box input:focus { background: var(--card2); border-color: rgba(255,64,129,0.2); }
.search-box input::placeholder { color: var(--text3); }
.search-box svg {
  position: absolute;
  left: 14px; top: 50%;
  transform: translateY(-50%);
  width: 18px; height: 18px;
  fill: var(--text3);
}

.tab-scroll {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 8px 16px 0 16px;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior-y: contain;
}

.track-list {
  display: flex;
  flex-direction: column;
  gap: 2px;
  padding-bottom: 160px;
}

.track-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 8px;
  border-radius: 12px;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.15s ease;
  animation: fadeInUp 0.4s ease forwards;
  opacity: 0;
  will-change: transform;
}
.track-item:active { background: var(--card); transform: scale(0.98); }
.track-item.playing { background: rgba(255,64,129,0.06); }
.track-item.playing .track-name { color: var(--accent); }

.track-img {
  width: 48px; height: 48px;
  border-radius: 10px;
  background: var(--card2);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  position: relative;
}
.track-img img { width: 100%; height: 100%; object-fit: cover; display: block; }
.track-img .placeholder-icon { width: 20px; height: 20px; fill: var(--text3); }

.track-item.playing .track-img::after {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.35);
  border-radius: 10px;
}

.track-info { flex: 1; min-width: 0; }
.track-name {
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  transition: color 0.2s;
}
.track-artist {
  font-size: 12px;
  color: var(--text2);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-top: 1px;
}

.track-fav {
  width: 36px; height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  cursor: pointer;
  border: none;
  background: none;
  transition: transform 0.15s;
}
.track-fav:active { transform: scale(0.75); }
.track-fav svg {
  width: 20px; height: 20px;
  fill: none;
  stroke: var(--text3);
  stroke-width: 2;
  transition: fill 0.3s, stroke 0.3s;
}
.track-fav.liked svg { fill: var(--accent); stroke: var(--accent); }

#mini-player {
  position: absolute;
  bottom: 68px;
  left: 8px; right: 8px;
  border-radius: 14px;
  padding: 10px 12px;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 100;
  transform: translateY(120%);
  transition: transform 0.4s cubic-bezier(0.22, 0.68, 0.32, 1);
  cursor: pointer;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.04);
  will-change: transform;
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  background: rgba(20,20,20,0.92);
}
#mini-player.show { transform: translateY(0); }

#mini-progress-bg {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  height: 2px;
  background: rgba(255,255,255,0.06);
}
#mini-progress {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  width: 0%;
  transition: width 0.3s linear;
}

.mini-img {
  width: 40px; height: 40px;
  border-radius: 8px;
  background: var(--card2);
  flex-shrink: 0;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}
.mini-img svg { width: 16px; height: 16px; fill: var(--text3); }
.mini-img img { width: 100%; height: 100%; object-fit: cover; display: block; }

.mini-info { flex: 1; min-width: 0; }
.mini-name {
  font-size: 13px; font-weight: 600;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.mini-artist {
  font-size: 11px; color: var(--text2);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

.mini-eq {
  display: flex;
  align-items: flex-end;
  gap: 2px;
  height: 18px;
  margin-right: 2px;
  flex-shrink: 0;
}
.mini-eq .eq-bar {
  width: 3px;
  border-radius: 1.5px;
  background: var(--accent);
  transition: height 0.12s ease;
}
.mini-eq.paused .eq-bar { height: 3px !important; }

.mini-play-btn {
  width: 36px; height: 36px;
  border: none; background: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.12s;
}
.mini-play-btn:active { transform: scale(0.8); }
.mini-play-btn svg { width: 24px; height: 24px; fill: white; }

.mini-fav {
  width: 32px; height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: none; background: none;
  cursor: pointer;
}
.mini-fav svg {
  width: 18px; height: 18px;
  fill: none; stroke: var(--text3);
  stroke-width: 2;
  transition: fill 0.3s, stroke 0.3s;
}
.mini-fav.liked svg { fill: var(--accent); stroke: var(--accent); }

#full-player {
  position: fixed;
  inset: 0;
  background: var(--bg);
  z-index: 500;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px 24px;
  transform: translateY(100%);
  transition: transform 0.45s cubic-bezier(0.22, 0.68, 0.32, 1);
  overflow-y: auto;
  will-change: transform;
}
#full-player.show { transform: translateY(0); }

.fp-close {
  width: 100%;
  display: flex;
  justify-content: center;
  padding: 8px 0 16px;
}
.fp-close-bar {
  width: 40px; height: 4px;
  border-radius: 2px;
  background: var(--text3);
  cursor: pointer;
}

.fp-img-container {
  position: relative;
  width: min(80vw, 340px);
  height: min(80vw, 340px);
  margin-bottom: 28px;
  flex-shrink: 0;
}

.fp-img {
  width: 100%; height: 100%;
  border-radius: 20px;
  background: var(--card);
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
}
.fp-img svg { width: 64px; height: 64px; fill: var(--text3); }
.fp-img img { width: 100%; height: 100%; object-fit: cover; display: block; }

.fp-equalizer {
  position: absolute;
  bottom: 16px; left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: flex-end;
  gap: 3px;
  height: 40px;
  z-index: 2;
  opacity: 0.9;
}
.fp-equalizer .eq-bar {
  width: 4px;
  border-radius: 2px;
  background: linear-gradient(to top, var(--accent), var(--accent2));
  transition: height 0.1s ease;
}
.fp-equalizer.paused .eq-bar { height: 4px !important; }

.fp-info {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 24px;
}
.fp-info-text { flex: 1; min-width: 0; }
.fp-name {
  font-size: 20px; font-weight: 700;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  letter-spacing: -0.3px;
}
.fp-artist { font-size: 14px; color: var(--text2); margin-top: 4px; }

.fp-actions { display: flex; gap: 8px; }
.fp-action-btn {
  width: 40px; height: 40px;
  border: none; background: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.12s;
}
.fp-action-btn:active { transform: scale(0.8); }
.fp-action-btn svg {
  width: 22px; height: 22px;
  fill: none; stroke: var(--text2);
  stroke-width: 2;
  transition: fill 0.3s, stroke 0.3s;
}
.fp-action-btn.liked svg { fill: var(--accent); stroke: var(--accent); }

.fp-progress { width: 100%; margin-bottom: 8px; }
.fp-progress-bar {
  width: 100%; height: 4px;
  background: rgba(255,255,255,0.1);
  border-radius: 2px;
  cursor: pointer;
  position: relative;
  transition: height 0.15s;
}
.fp-progress-bar:active,
.fp-progress-bar.dragging { height: 6px; }
.fp-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  border-radius: 2px;
  width: 0%;
  position: relative;
  transition: width 0.1s linear;
}
.fp-progress-fill::after {
  content: '';
  position: absolute;
  right: -7px; top: 50%;
  transform: translateY(-50%);
  width: 14px; height: 14px;
  border-radius: 50%;
  background: white;
  box-shadow: 0 0 8px rgba(0,0,0,0.3);
  opacity: 0;
  transition: opacity 0.2s;
}
.fp-progress-bar:active .fp-progress-fill::after,
.fp-progress-bar.dragging .fp-progress-fill::after { opacity: 1; }
.fp-times {
  display: flex;
  justify-content: space-between;
  font-size: 11px; color: var(--text3);
  margin-top: 8px;
  font-variant-numeric: tabular-nums;
}

.fp-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 24px;
  margin-top: 24px;
  width: 100%;
}
.fp-ctrl {
  border: none; background: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.15s ease;
}
.fp-ctrl:active { transform: scale(0.82); }
.fp-ctrl svg { fill: white; transition: fill 0.3s; }
.fp-ctrl.active svg { fill: var(--accent); }
.fp-ctrl-sm svg { width: 24px; height: 24px; }
.fp-ctrl-md svg { width: 32px; height: 32px; }
.fp-ctrl-lg {
  width: 64px; height: 64px;
  border-radius: 50%;
  background: white;
  transition: transform 0.12s;
}
.fp-ctrl-lg:active { transform: scale(0.88); }
.fp-ctrl-lg svg { fill: var(--bg); width: 28px; height: 28px; }

.fp-download {
  margin-top: 28px;
  padding: 10px 24px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 50px;
  background: none;
  color: var(--text2);
  font-size: 13px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s;
  margin-bottom: 32px;
}
.fp-download:active { transform: scale(0.95); }
.fp-download svg { width: 16px; height: 16px; fill: var(--text2); }
.fp-download.downloaded { border-color: var(--green); color: var(--green); }
.fp-download.downloaded svg { fill: var(--green); }

#bottom-nav {
  display: flex;
  align-items: center;
  justify-content: space-around;
  height: 60px; min-height: 60px;
  border-top: 1px solid rgba(255,255,255,0.04);
  padding-bottom: var(--safe-bottom);
  z-index: 200;
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  background: rgba(20,20,20,0.95);
}

.nav-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  border: none; background: none;
  cursor: pointer;
  padding: 8px 16px;
  transition: transform 0.12s;
}
.nav-btn:active { transform: scale(0.88); }
.nav-btn svg { width: 22px; height: 22px; fill: var(--text3); transition: fill 0.25s; }
.nav-btn span { font-size: 10px; color: var(--text3); transition: color 0.25s; }
.nav-btn.active svg { fill: var(--accent); }
.nav-btn.active span { color: var(--accent); }

.playlists-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  padding-bottom: 160px;
}

.playlist-card {
  background: var(--card);
  border-radius: 14px;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.15s;
  animation: fadeInUp 0.4s ease forwards;
  opacity: 0;
  border: 1px solid rgba(255,255,255,0.03);
}
.playlist-card:active { transform: scale(0.96); }

.playlist-card-img {
  width: 100%;
  aspect-ratio: 1;
  background: var(--card2);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
.playlist-card-img svg { width: 40px; height: 40px; fill: var(--text3); }
.playlist-card-img img { width: 100%; height: 100%; object-fit: cover; }

.playlist-card-info { padding: 10px 12px; }
.playlist-card-name {
  font-size: 13px; font-weight: 600;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.playlist-card-count { font-size: 11px; color: var(--text3); margin-top: 2px; }

.playlist-create { border: 2px dashed rgba(255,255,255,0.1); background: transparent; }
.playlist-create .playlist-card-img { background: transparent; }

#playlist-view {
  position: fixed; inset: 0;
  background: var(--bg);
  z-index: 400;
  transform: translateX(100%);
  transition: transform 0.35s cubic-bezier(0.22, 0.68, 0.32, 1);
  display: flex;
  flex-direction: column;
  will-change: transform;
}
#playlist-view.show { transform: translateX(0); }

.pv-header { display: flex; align-items: center; gap: 12px; padding: 16px; }
.pv-back {
  width: 36px; height: 36px;
  border: none; background: none;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
}
.pv-back svg { width: 24px; height: 24px; fill: white; }
.pv-title { font-size: 20px; font-weight: 700; flex: 1; }
.pv-delete {
  width: 36px; height: 36px;
  border: none; background: none;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
}
.pv-delete svg { width: 20px; height: 20px; fill: var(--red); }

.pv-actions { display: flex; gap: 10px; padding: 0 16px 12px; }
.pv-action-btn {
  flex: 1;
  padding: 10px;
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 10px;
  background: none;
  color: var(--text2);
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  transition: background 0.15s;
}
.pv-action-btn:active { background: var(--card); }
.pv-action-btn svg { width: 16px; height: 16px; fill: var(--text2); }

.pv-content { flex: 1; overflow-y: auto; padding: 0 16px 120px; }

#add-tracks-modal {
  position: fixed; inset: 0;
  background: var(--bg);
  z-index: 450;
  transform: translateY(100%);
  transition: transform 0.35s cubic-bezier(0.22, 0.68, 0.32, 1);
  display: flex;
  flex-direction: column;
}
#add-tracks-modal.show { transform: translateY(0); }

.atm-header { display: flex; align-items: center; gap: 12px; padding: 16px; }
.atm-close {
  width: 36px; height: 36px;
  border: none; background: none;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
}
.atm-close svg { width: 24px; height: 24px; fill: white; }
.atm-title { font-size: 18px; font-weight: 700; flex: 1; }
.atm-done {
  padding: 8px 16px;
  border: none;
  border-radius: 20px;
  background: var(--accent);
  color: white;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
}

.atm-content { flex: 1; overflow-y: auto; padding: 0 16px 40px; }

.track-item-selectable {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 8px;
  border-radius: 12px;
  cursor: pointer;
  transition: background 0.15s;
}
.track-item-selectable:active { background: var(--card); }

.select-check {
  width: 22px; height: 22px;
  border: 2px solid var(--text3);
  border-radius: 6px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.select-check.checked { background: var(--accent); border-color: var(--accent); }
.select-check svg { width: 14px; height: 14px; fill: white; opacity: 0; transition: opacity 0.2s; }
.select-check.checked svg { opacity: 1; }

#create-playlist-modal {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 600;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 32px;
  opacity: 0;
  transition: opacity 0.3s;
  backdrop-filter: blur(8px);
}
#create-playlist-modal.show { display: flex; opacity: 1; }

.cpm-card {
  background: var(--card);
  border-radius: 20px;
  padding: 28px 24px;
  width: 100%; max-width: 320px;
  border: 1px solid rgba(255,255,255,0.05);
}
.cpm-title { font-size: 18px; font-weight: 700; margin-bottom: 16px; text-align: center; }
.cpm-input {
  width: 100%;
  padding: 12px 16px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  background: var(--bg);
  color: white;
  font-size: 14px;
  outline: none;
  margin-bottom: 16px;
  user-select: text;
  transition: border-color 0.2s;
}
.cpm-input:focus { border-color: var(--accent); }
.cpm-buttons { display: flex; gap: 10px; }
.cpm-btn {
  flex: 1; padding: 12px;
  border: none; border-radius: 12px;
  font-size: 14px; font-weight: 600;
  cursor: pointer;
  transition: transform 0.12s;
}
.cpm-btn:active { transform: scale(0.95); }
.cpm-cancel { background: var(--card2); color: var(--text2); }
.cpm-create { background: linear-gradient(135deg, var(--accent), var(--accent2)); color: white; }

.upload-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px;
  border: 2px dashed rgba(255,255,255,0.1);
  border-radius: 12px;
  background: none;
  color: var(--text2);
  font-size: 13px;
  cursor: pointer;
  margin-bottom: 12px;
  width: 100%;
  transition: border-color 0.2s, color 0.2s;
}
.upload-btn:active { border-color: var(--accent); color: var(--accent); }
.upload-btn svg { width: 20px; height: 20px; fill: var(--text2); }

#toast {
  position: fixed;
  bottom: 140px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: rgba(30,30,30,0.95);
  color: var(--text);
  padding: 10px 20px;
  border-radius: 10px;
  font-size: 13px;
  z-index: 9999;
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.22, 0.68, 0.32, 1);
  pointer-events: none;
  white-space: nowrap;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.06);
}
#toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

@keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

.loading { display: flex; align-items: center; justify-content: center; padding: 40px; }
.spinner {
  width: 32px; height: 32px;
  border: 3px solid var(--card2);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

.empty-state { text-align: center; padding: 40px 20px; color: var(--text3); }
.empty-state svg { width: 48px; height: 48px; fill: var(--text3); margin-bottom: 12px; }
.empty-state p { font-size: 14px; }
</style>
</head>
<body>

<div id="toast"></div>

<div id="splash">
  <div class="splash-title">Lips-songs</div>
  <div class="splash-card">
    <h3>Что нового</h3>
    <ul>
      <li>Добавляй свои треки</li>
      <li>Визуализатор эквалайзера</li>
      <li>Плавные жесты управления</li>
      <li>Офлайн режим</li>
      <li>Плейлисты и избранное</li>
    </ul>
  </div>
  <div class="status-indicator">
    <div class="status-dot" id="splash-status-dot"></div>
    <span id="splash-status-text">Онлайн</span>
  </div>
  <button class="splash-btn" onclick="enterApp()">Войти</button>
</div>

<div id="app">
  <div id="tabs-container">
    <div id="tabs-wrapper">

      <!-- HOME -->
      <div class="tab-page" id="page-home">
        <div class="tab-header">
          <h1 class="page-title">Главная</h1>
          <div class="search-box">
            <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27A6.47 6.47 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
            <input type="text" placeholder="Поиск треков или артистов..." id="search-home" oninput="doSearch('home')">
          </div>
        </div>
        <div class="tab-scroll">
          <div class="track-list" id="home-tracks"><div class="loading"><div class="spinner"></div></div></div>
        </div>
      </div>

      <!-- PLAYLISTS -->
      <div class="tab-page" id="page-playlists">
        <div class="tab-header">
          <h1 class="page-title">Плейлисты</h1>
        </div>
        <div class="tab-scroll">
          <div class="playlists-grid" id="playlists-grid"></div>
        </div>
      </div>

      <!-- FAVORITES -->
      <div class="tab-page" id="page-favorites">
        <div class="tab-header">
          <h1 class="page-title">Избранное</h1>
          <div class="search-box">
            <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27A6.47 6.47 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
            <input type="text" placeholder="Поиск в избранном..." id="search-fav" oninput="doSearch('fav')">
          </div>
        </div>
        <div class="tab-scroll">
          <div class="track-list" id="fav-tracks"></div>
        </div>
      </div>

      <!-- DOWNLOADS -->
      <div class="tab-page" id="page-downloads">
        <div class="tab-header">
          <h1 class="page-title">Скачанное</h1>
          <div class="search-box">
            <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27A6.47 6.47 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
            <input type="text" placeholder="Поиск в скачанном..." id="search-dl" oninput="doSearch('dl')">
          </div>
          <button class="upload-btn" onclick="uploadLocalTracks()">
            <svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
            Добавить свои треки
          </button>
        </div>
        <div class="tab-scroll">
          <div class="track-list" id="dl-tracks"></div>
        </div>
      </div>

    </div>
  </div>

  <div id="mini-player" onclick="openFullPlayer(event)">
    <div class="mini-img" id="mini-img-wrap">
      <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
    </div>
    <div class="mini-info">
      <div class="mini-name" id="mini-name">--</div>
      <div class="mini-artist" id="mini-artist">--</div>
    </div>
    <div class="mini-eq" id="mini-eq">
      <div class="eq-bar" style="height:3px"></div>
      <div class="eq-bar" style="height:3px"></div>
      <div class="eq-bar" style="height:3px"></div>
      <div class="eq-bar" style="height:3px"></div>
    </div>
    <button class="mini-play-btn" onclick="togglePlay(event)">
      <svg id="mini-play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    </button>
    <button class="mini-fav" id="mini-fav-btn" onclick="toggleCurrentFav(event)">
      <svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 00-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 00-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 000-7.78z"/></svg>
    </button>
    <div id="mini-progress-bg"><div id="mini-progress"></div></div>
  </div>

  <nav id="bottom-nav">
    <button class="nav-btn active" onclick="switchTab(0)" data-tab="0">
      <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
      <span>Главная</span>
    </button>
    <button class="nav-btn" onclick="switchTab(1)" data-tab="1">
      <svg viewBox="0 0 24 24"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>
      <span>Плейлисты</span>
    </button>
    <button class="nav-btn" onclick="switchTab(2)" data-tab="2">
      <svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 00-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 00-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 000-7.78z"/></svg>
      <span>Избранное</span>
    </button>
    <button class="nav-btn" onclick="switchTab(3)" data-tab="3">
      <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
      <span>Скачанное</span>
    </button>
  </nav>
</div>

<div id="full-player">
  <div class="fp-close" onclick="closeFullPlayer()"><div class="fp-close-bar"></div></div>
  <div class="fp-img-container">
    <div class="fp-img" id="fp-img-wrap">
      <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
    </div>
    <div class="fp-equalizer" id="fp-equalizer">
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
      <div class="eq-bar" style="height:4px"></div>
    </div>
  </div>
  <div class="fp-info">
    <div class="fp-info-text">
      <div class="fp-name" id="fp-name">--</div>
      <div class="fp-artist" id="fp-artist">--</div>
    </div>
    <div class="fp-actions">
      <button class="fp-action-btn" id="fp-like-btn" onclick="toggleCurrentFav()">
        <svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 00-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 00-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 000-7.78z"/></svg>
      </button>
    </div>
  </div>
  <div class="fp-progress">
    <div class="fp-progress-bar" id="fp-progress-bar">
      <div class="fp-progress-fill" id="fp-progress-fill"></div>
    </div>
    <div class="fp-times">
      <span id="fp-current-time">0:00</span>
      <span id="fp-duration">0:00</span>
    </div>
  </div>
  <div class="fp-controls">
    <button class="fp-ctrl fp-ctrl-sm" id="fp-shuffle" onclick="toggleShuffle()">
      <svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>
    </button>
    <button class="fp-ctrl fp-ctrl-md" onclick="prevTrack()">
      <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
    </button>
    <button class="fp-ctrl fp-ctrl-lg" onclick="togglePlay()">
      <svg id="fp-play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    </button>
    <button class="fp-ctrl fp-ctrl-md" onclick="nextTrack()">
      <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
    </button>
    <button class="fp-ctrl fp-ctrl-sm" id="fp-repeat" onclick="toggleRepeat()">
      <svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>
    </button>
  </div>
  <button class="fp-download" id="fp-download-btn" onclick="downloadCurrentTrack()">
    <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
    <span id="fp-download-text">Скачать</span>
  </button>
</div>

<div id="playlist-view">
  <div class="pv-header">
    <button class="pv-back" onclick="closePlaylistView()">
      <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
    </button>
    <div class="pv-title" id="pv-title">Плейлист</div>
    <button class="pv-delete" onclick="deletePlaylist()">
      <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
    </button>
  </div>
  <div class="pv-actions">
    <button class="pv-action-btn" onclick="addTracksToPlaylist('all')">
      <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
      Добавить треки
    </button>
    <button class="pv-action-btn" onclick="addTracksToPlaylist('fav')">
      <svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 00-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 00-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 000-7.78z"/></svg>
      Из избранного
    </button>
  </div>
  <div class="pv-content">
    <div class="track-list" id="pv-tracks"></div>
  </div>
</div>

<div id="add-tracks-modal">
  <div class="atm-header">
    <button class="atm-close" onclick="closeAddTracksModal()">
      <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
    </button>
    <div class="atm-title" id="atm-title">Добавить треки</div>
    <button class="atm-done" onclick="doneAddTracks()">Готово</button>
  </div>
  <div class="search-box" style="padding:0 16px 12px;">
    <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27A6.47 6.47 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
    <input type="text" placeholder="Поиск..." id="search-add-tracks" oninput="searchAddTracks()">
  </div>
  <div class="atm-content" id="atm-tracks-list"></div>
</div>

<div id="create-playlist-modal">
  <div class="cpm-card">
    <div class="cpm-title">Новый плейлист</div>
    <input class="cpm-input" id="cpm-input" type="text" placeholder="Название плейлиста" maxlength="50">
    <div class="cpm-buttons">
      <button class="cpm-btn cpm-cancel" onclick="closeCreatePlaylist()">Отмена</button>
      <button class="cpm-btn cpm-create" onclick="createPlaylist()">Создать</button>
    </div>
  </div>
</div>

<audio id="audio" preload="auto" crossorigin="anonymous"></audio>
<input type="file" id="file-input" accept="audio/*" multiple style="display:none" onchange="handleFileUpload(event)">

<script>
const GITHUB_API = 'https://api.github.com/repos/Ksaers748/MSBD/contents/track';
const GITHUB_RAW = 'https://raw.githubusercontent.com/Ksaers748/MSBD/main/track/';
const CATALOG_URL = GITHUB_RAW + 'catalog.json';

let allTracks = [];
let favorites = [];
let playlists = [];
let downloaded = [];
let localTracks = [];
let currentTrack = null;
let currentQueue = [];
let currentQueueIndex = -1;
let isPlaying = false;
let isShuffle = false;
let repeatMode = 0;
let currentTab = 0;
let isFirstVisit = true;
let currentPlaylistViewId = null;
let addTracksMode = 'all';
let selectedAddTracks = new Set();

// image cache: trackId -> blob URL
const coverCache = {};

const audio = document.getElementById('audio');
const DB_NAME = 'LipsSongsDB';
const DB_VERSION = 4;
let db = null;

// ===================== AUDIO CONTEXT & ANALYSER =====================
let audioCtx = null;
let analyser = null;
let sourceNode = null;
let eqDataArray = null;
let eqAnimFrame = null;

function initAudioContext() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 64;
    analyser.smoothingTimeConstant = 0.75;
    sourceNode = audioCtx.createMediaElementSource(audio);
    sourceNode.connect(analyser);
    analyser.connect(audioCtx.destination);
    eqDataArray = new Uint8Array(analyser.frequencyBinCount);
  } catch(e) {
    console.warn('AudioContext init failed:', e);
  }
}

function startEqAnimation() {
  if (!analyser || !eqDataArray) return;
  function animate() {
    analyser.getByteFrequencyData(eqDataArray);
    const miniBars = document.getElementById('mini-eq').querySelectorAll('.eq-bar');
    const step = Math.floor(eqDataArray.length / 4);
    miniBars.forEach((bar, i) => {
      bar.style.height = Math.max(3, (eqDataArray[i * step] / 255) * 18) + 'px';
    });
    const fpBars = document.getElementById('fp-equalizer').querySelectorAll('.eq-bar');
    const fpStep = Math.floor(eqDataArray.length / 12);
    fpBars.forEach((bar, i) => {
      bar.style.height = Math.max(4, (eqDataArray[Math.min(i * fpStep, eqDataArray.length - 1)] / 255) * 40) + 'px';
    });
    eqAnimFrame = requestAnimationFrame(animate);
  }
  cancelAnimationFrame(eqAnimFrame);
  animate();
}

function stopEqAnimation() {
  cancelAnimationFrame(eqAnimFrame);
  document.getElementById('mini-eq').classList.add('paused');
  document.getElementById('fp-equalizer').classList.add('paused');
}

function resumeEqAnimation() {
  document.getElementById('mini-eq').classList.remove('paused');
  document.getElementById('fp-equalizer').classList.remove('paused');
  startEqAnimation();
}

// ===================== ID3 TAG + COVER READER =====================
function parseID3v2(buf) {
  const view = new DataView(buf);
  const version = view.getUint8(3);
  let offset = 10;
  const size = ((view.getUint8(6) & 0x7f) << 21) |
               ((view.getUint8(7) & 0x7f) << 14) |
               ((view.getUint8(8) & 0x7f) << 7) |
               (view.getUint8(9) & 0x7f);
  const end = Math.min(10 + size, buf.byteLength);
  const tags = {};

  while (offset < end - 10) {
    let frameId, frameSize, headerSize;

    if (version >= 3) {
      if (offset + 10 > end) break;
      frameId = String.fromCharCode(view.getUint8(offset), view.getUint8(offset+1), view.getUint8(offset+2), view.getUint8(offset+3));
      if (version === 4) {
        frameSize = ((view.getUint8(offset+4) & 0x7f) << 21) |
                    ((view.getUint8(offset+5) & 0x7f) << 14) |
                    ((view.getUint8(offset+6) & 0x7f) << 7) |
                    (view.getUint8(offset+7) & 0x7f);
      } else {
        frameSize = (view.getUint8(offset+4) << 24) |
                    (view.getUint8(offset+5) << 16) |
                    (view.getUint8(offset+6) << 8) |
                    view.getUint8(offset+7);
      }
      headerSize = 10;
    } else {
      if (offset + 6 > end) break;
      frameId = String.fromCharCode(view.getUint8(offset), view.getUint8(offset+1), view.getUint8(offset+2));
      frameSize = (view.getUint8(offset+3) << 16) |
                  (view.getUint8(offset+4) << 8) |
                  view.getUint8(offset+5);
      headerSize = 6;
    }

    if (frameSize <= 0 || frameSize > end - offset - headerSize) break;
    if (!frameId.match(/^[A-Z0-9]+$/)) break;

    const dataOffset = offset + headerSize;
    const textFrames = { 'TIT2': 'title', 'TPE1': 'artist', 'TALB': 'album', 'TT2': 'title', 'TP1': 'artist', 'TAL': 'album' };

    if (textFrames[frameId]) {
      try {
        const encoding = view.getUint8(dataOffset);
        let text = '';
        if (encoding === 0 || encoding === 3) {
          text = new TextDecoder(encoding === 3 ? 'utf-8' : 'iso-8859-1').decode(new Uint8Array(buf, dataOffset + 1, frameSize - 1));
        } else if (encoding === 1 || encoding === 2) {
          const bytes = new Uint8Array(buf, dataOffset + 1, frameSize - 1);
          let dec = 'utf-16be';
          if (bytes.length >= 2) {
            if (bytes[0] === 0xFF && bytes[1] === 0xFE) dec = 'utf-16le';
            else if (bytes[0] === 0xFE && bytes[1] === 0xFF) dec = 'utf-16be';
          }
          text = new TextDecoder(dec).decode(bytes);
          if (text.charCodeAt(0) === 0xFEFF || text.charCodeAt(0) === 0xFFFE) text = text.substring(1);
        }
        text = text.replace(/\0/g, '').trim();
        if (text) tags[textFrames[frameId]] = text;
      } catch(e) {}
    }

    // APIC frame (album art)
    if (frameId === 'APIC' || frameId === 'PIC') {
      try {
        let pos = dataOffset;
        const encoding = view.getUint8(pos); pos++;

        if (frameId === 'APIC') {
          // MIME type (null-terminated)
          let mime = '';
          while (pos < dataOffset + frameSize && view.getUint8(pos) !== 0) {
            mime += String.fromCharCode(view.getUint8(pos)); pos++;
          }
          pos++; // skip null
          pos++; // skip picture type byte
          // description (null-terminated, encoding-dependent)
          if (encoding === 0 || encoding === 3) {
            while (pos < dataOffset + frameSize && view.getUint8(pos) !== 0) pos++;
            pos++;
          } else {
            // UTF-16: look for double null
            while (pos < dataOffset + frameSize - 1) {
              if (view.getUint8(pos) === 0 && view.getUint8(pos+1) === 0) { pos += 2; break; }
              pos += 2;
            }
          }
          if (!mime || mime === 'image/') mime = 'image/jpeg';
          const imgData = new Uint8Array(buf, pos, dataOffset + frameSize - pos);
          if (imgData.length > 100) {
            tags.coverBlob = new Blob([imgData], { type: mime });
          }
        } else {
          // PIC (ID3v2.2)
          const imgFormat = String.fromCharCode(view.getUint8(pos), view.getUint8(pos+1), view.getUint8(pos+2));
          pos += 3;
          pos++; // picture type
          while (pos < dataOffset + frameSize && view.getUint8(pos) !== 0) pos++;
          pos++;
          const mime2 = imgFormat.toLowerCase() === 'png' ? 'image/png' : 'image/jpeg';
          const imgData2 = new Uint8Array(buf, pos, dataOffset + frameSize - pos);
          if (imgData2.length > 100) {
            tags.coverBlob = new Blob([imgData2], { type: mime2 });
          }
        }
      } catch(e) {}
    }

    offset = dataOffset + frameSize;
  }

  return (tags.title || tags.artist || tags.coverBlob) ? tags : null;
}

async function readID3Tags(url) {
  try {
    // Fetch enough bytes for cover art (up to 512KB)
    const resp = await fetch(url, { headers: { 'Range': 'bytes=0-524288' } });
    const buf = await resp.arrayBuffer();
    const view = new DataView(buf);
    if (view.getUint8(0) === 0x49 && view.getUint8(1) === 0x44 && view.getUint8(2) === 0x33) {
      return parseID3v2(buf);
    }
    return null;
  } catch(e) { return null; }
}

async function readID3FromBlob(blob) {
  try {
    // Read up to 512KB for embedded cover
    const size = Math.min(blob.size, 524288);
    const slice = blob.slice(0, size);
    const buf = await slice.arrayBuffer();
    const view = new DataView(buf);
    if (view.getUint8(0) === 0x49 && view.getUint8(1) === 0x44 && view.getUint8(2) === 0x33) {
      return parseID3v2(buf);
    }
    return null;
  } catch(e) { return null; }
}

// ===================== INDEXEDDB =====================
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('audioCache')) d.createObjectStore('audioCache', { keyPath: 'id' });
      if (!d.objectStoreNames.contains('state')) d.createObjectStore('state', { keyPath: 'key' });
      if (!d.objectStoreNames.contains('coverCache')) d.createObjectStore('coverCache', { keyPath: 'id' });
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e);
  });
}

function dbPut(store, data) {
  return new Promise((res, rej) => {
    try {
      const tx = db.transaction(store, 'readwrite');
      tx.objectStore(store).put(data);
      tx.oncomplete = res; tx.onerror = rej;
    } catch(e) { rej(e); }
  });
}

function dbGet(store, key) {
  return new Promise((res, rej) => {
    try {
      const tx = db.transaction(store, 'readonly');
      const r = tx.objectStore(store).get(key);
      r.onsuccess = () => res(r.result); r.onerror = rej;
    } catch(e) { rej(e); }
  });
}

async function saveCover(trackId, blob) {
  try {
    if (db.objectStoreNames.contains('coverCache')) {
      await dbPut('coverCache', { id: trackId, blob });
    }
  } catch(e) {}
}

async function loadCover(trackId) {
  try {
    if (!db.objectStoreNames.contains('coverCache')) return null;
    const r = await dbGet('coverCache', trackId);
    return r ? r.blob : null;
  } catch(e) { return null; }
}

async function saveAppState() {
  if (!db) return;
  await dbPut('state', { key: 'favorites', value: favorites });
  await dbPut('state', { key: 'playlists', value: playlists });
  await dbPut('state', { key: 'downloaded', value: downloaded });
  await dbPut('state', { key: 'localTracks', value: localTracks.map(t => ({ ...t, src: '', img: t.img && t.img.startsWith('blob:') ? '' : t.img })) });
  await dbPut('state', { key: 'currentTab', value: currentTab });
  await dbPut('state', { key: 'hasVisited', value: true });
  if (allTracks.length > 0) {
    await dbPut('state', { key: 'cachedTracks', value: allTracks.map(t => ({ ...t, img: t.img && t.img.startsWith('blob:') ? '' : t.img })) });
  }
}

async function loadAppState() {
  if (!db) return;
  try {
    const f = await dbGet('state', 'favorites');
    if (f) favorites = f.value || [];
    const p = await dbGet('state', 'playlists');
    if (p) playlists = p.value || [];
    const d = await dbGet('state', 'downloaded');
    if (d) downloaded = d.value || [];
    const l = await dbGet('state', 'localTracks');
    if (l && l.value) {
      localTracks = l.value;
      for (let t of localTracks) {
        const cached = await dbGet('audioCache', t.id);
        if (cached && cached.blob) t.src = URL.createObjectURL(cached.blob);
        // restore cover
        const coverBlob = await loadCover(t.id);
        if (coverBlob) {
          const url = URL.createObjectURL(coverBlob);
          t.img = url;
          coverCache[t.id] = url;
        }
      }
    }
    const tab = await dbGet('state', 'currentTab');
    if (tab) currentTab = tab.value || 0;
    const visited = await dbGet('state', 'hasVisited');
    if (visited && visited.value) isFirstVisit = false;
  } catch(e) { console.error('Load state error:', e); }
}

async function getCachedTracks() {
  try {
    const ct = await dbGet('state', 'cachedTracks');
    const tracks = ct ? ct.value || [] : [];
    // Restore covers from cache
    for (let t of tracks) {
      const coverBlob = await loadCover(t.id);
      if (coverBlob) {
        const url = URL.createObjectURL(coverBlob);
        t.img = url;
        coverCache[t.id] = url;
      }
    }
    return tracks;
  } catch(e) { return []; }
}

// ===================== LOAD TRACKS =====================
async function loadTracksFromGithub() {
  try {
    const resp = await fetch(GITHUB_API);
    if (!resp.ok) throw new Error('API ' + resp.status);
    const files = await resp.json();
    if (!Array.isArray(files)) throw new Error('Not array');

    const audioFiles = files.filter(f =>
      /\.(mp3|wav|ogg|m4a|flac|aac|webm)$/i.test(f.name)
    );

    let catalog = [];
    try {
      const catResp = await fetch(CATALOG_URL + '?t=' + Date.now());
      if (catResp.ok) catalog = await catResp.json();
    } catch(e) {}

    const catalogMap = {};
    catalog.forEach(c => { catalogMap[c.file] = c; });

    // First pass: create tracks with basic info (filename-based)
    const tracks = audioFiles.map(f => {
      const catEntry = catalogMap[f.name];
      const fileUrl = f.download_url || (GITHUB_RAW + encodeURIComponent(f.name));
      let title, artist, album = '', cover = '';

      if (catEntry) {
        title = catEntry.title || f.name.replace(/\.[^.]+$/, '');
        artist = catEntry.artist || 'Неизвестный';
        album = catEntry.album || '';
        cover = catEntry.cover || '';
      } else {
        const nameNoExt = f.name.replace(/\.[^.]+$/, '');
        const parts = nameNoExt.split(' - ');
        if (parts.length >= 2) {
          artist = parts[0].trim();
          title = parts.slice(1).join(' - ').trim();
        } else {
          artist = 'Неизвестный';
          title = nameNoExt;
        }
      }

      return {
        id: 'gh_' + f.sha,
        name: title,
        artist: artist,
        album: album,
        src: fileUrl,
        img: cover,
        isLocal: false,
        fileName: f.name,
        _hasCatalog: !!catEntry,
        _url: fileUrl
      };
    });

    // Show tracks immediately
    allTracks = tracks;
    renderAll();

    // Second pass: read ID3 for tracks without catalog entry (in background)
    const needsID3 = tracks.filter(t => !t._hasCatalog);
    const batchSize = 3;
    for (let i = 0; i < needsID3.length; i += batchSize) {
      const batch = needsID3.slice(i, i + batchSize);
      await Promise.allSettled(batch.map(async (t) => {
        try {
          const tags = await readID3Tags(t._url);
          if (tags) {
            if (tags.title) t.name = tags.title;
            if (tags.artist) t.artist = tags.artist;
            if (tags.album) t.album = tags.album;
            if (tags.coverBlob) {
              const url = URL.createObjectURL(tags.coverBlob);
              t.img = url;
              coverCache[t.id] = url;
              await saveCover(t.id, tags.coverBlob);
            }
          }
        } catch(e) {}
      }));
      renderAll();
    }

    // Clean temp properties
    tracks.forEach(t => { delete t._hasCatalog; delete t._url; });

    return tracks;
  } catch (e) {
    console.error('GitHub load error:', e);
    return [];
  }
}

// ===================== SEARCH =====================
const ruToEn = {'й':'q','ц':'w','у':'e','к':'r','е':'t','н':'y','г':'u','ш':'i','щ':'o','з':'p','х':'[','ъ':']','ф':'a','ы':'s','в':'d','а':'f','п':'g','р':'h','о':'j','л':'k','д':'l','ж':';','э':"'",'я':'z','ч':'x','с':'c','м':'v','и':'b','т':'n','ь':'m','б':',','ю':'.'};
const enToRu = {};
for (const [k, v] of Object.entries(ruToEn)) enToRu[v] = k;

function convertLayout(str) {
  let r1 = '', r2 = '';
  for (const c of str.toLowerCase()) {
    r1 += ruToEn[c] || c;
    r2 += enToRu[c] || c;
  }
  return [r1, r2];
}

function levenshtein(a, b) {
  const m = a.length, n = b.length;
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++)
    for (let j = 1; j <= n; j++)
      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(a[i-1]===b[j-1]?0:1));
  return dp[m][n];
}

function filterTracks(tracks, query) {
  if (!query || !query.trim()) return tracks;
  const q = query.toLowerCase().trim();
  const [qEn, qRu] = convertLayout(q);
  return tracks.map(t => {
    const name = t.name.toLowerCase();
    const artist = t.artist.toLowerCase();
    const full = artist + ' ' + name;
    let score = 0;
    if (name === q || artist === q) score = 200;
    else if (name.startsWith(q) || artist.startsWith(q)) score = 150;
    else if (full.includes(q)) score = 100;
    else if (full.includes(qEn) || full.includes(qRu)) score = 80;
    else {
      const qWords = q.split(/\s+/);
      const fWords = full.split(/\s+/);
      let matched = 0;
      for (const qw of qWords) {
        for (const fw of fWords) {
          if (fw.includes(qw)) { matched++; break; }
          const [qwE, qwR] = convertLayout(qw);
          if (fw.includes(qwE) || fw.includes(qwR)) { matched++; break; }
          if (levenshtein(qw, fw.substring(0, qw.length + 2)) <= Math.max(1, Math.floor(qw.length / 3))) { matched += 0.7; break; }
        }
      }
      score = (matched / qWords.length) * 60;
    }
    return { track: t, score };
  }).filter(r => r.score > 0).sort((a, b) => b.score - a.score).map(r => r.track);
}

// ===================== HELPERS =====================
function getAllTracksArray() { return [...allTracks, ...localTracks]; }

function getTrackList(ctx) {
  const all = getAllTracksArray();
  switch (ctx) {
    case 'home':
      if (!navigator.onLine) {
        const dlSet = new Set(downloaded);
        return filterTracks(all.filter(t => t.isLocal || dlSet.has(t.id)), document.getElementById('search-home').value);
      }
      return filterTracks(all, document.getElementById('search-home').value);
    case 'fav':
      return filterTracks(all.filter(t => favorites.includes(t.id)), document.getElementById('search-fav').value);
    case 'dl':
      const dlSet2 = new Set(downloaded);
      return filterTracks(all.filter(t => t.isLocal || dlSet2.has(t.id)), document.getElementById('search-dl').value);
    default: return all;
  }
}

function escapeHtml(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

function formatTime(sec) {
  if (isNaN(sec)) return '0:00';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return m + ':' + (s < 10 ? '0' : '') + s;
}

function pluralize(n) {
  const a = Math.abs(n) % 100;
  const n1 = a % 10;
  if (a > 10 && a < 20) return 'ов';
  if (n1 > 1 && n1 < 5) return 'а';
  if (n1 === 1) return '';
  return 'ов';
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(t._timer);
  t._timer = setTimeout(() => t.classList.remove('show'), 2000);
}

// ===================== RENDER =====================
const HEART_SVG = '<svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 00-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 00-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 000-7.78z"/></svg>';
const MUSIC_SVG = '<svg class="placeholder-icon" viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>';

function renderTrackItem(track, index, context) {
  const isFav = favorites.includes(track.id);
  const isCurrent = currentTrack && currentTrack.id === track.id;
  const div = document.createElement('div');
  div.className = 'track-item' + (isCurrent ? ' playing' : '');
  div.style.animationDelay = Math.min(index * 0.03, 0.5) + 's';

  const imgSrc = track.img || coverCache[track.id] || '';
  const imgHtml = imgSrc
    ? `<img src="${escapeHtml(imgSrc)}" alt="" loading="lazy" onerror="this.style.display='none';this.nextElementSibling.style.display='block'"><svg class="placeholder-icon" style="display:none" viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>`
    : MUSIC_SVG;

  div.innerHTML = `
    <div class="track-img">${imgHtml}</div>
    <div class="track-info">
      <div class="track-name">${escapeHtml(track.name)}</div>
      <div class="track-artist">${escapeHtml(track.artist)}</div>
    </div>
    <button class="track-fav ${isFav ? 'liked' : ''}">${HEART_SVG}</button>
  `;

  const playHandler = () => {
    const list = getTrackList(context);
    const idx = list.findIndex(t => t.id === track.id);
    playFromList(list, idx >= 0 ? idx : 0);
  };
  div.querySelector('.track-info').addEventListener('click', playHandler);
  div.querySelector('.track-img').addEventListener('click', playHandler);
  div.querySelector('.track-fav').addEventListener('click', (e) => {
    e.stopPropagation();
    toggleFavorite(track.id);
  });
  return div;
}

function renderTracks(context) {
  const tracks = getTrackList(context);
  const cid = context === 'home' ? 'home-tracks' : context === 'fav' ? 'fav-tracks' : 'dl-tracks';
  const container = document.getElementById(cid);
  container.innerHTML = '';

  if (tracks.length === 0) {
    const msg = context === 'fav' ? 'Нет избранных треков' :
                context === 'dl' ? 'Нет скачанных треков' :
                (navigator.onLine ? 'Треки не найдены' : 'Нет доступных треков офлайн');
    container.innerHTML = `<div class="empty-state"><svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>${msg}</p></div>`;
    return;
  }
  tracks.forEach((t, i) => container.appendChild(renderTrackItem(t, i, context)));
}

function renderPlaylists() {
  const grid = document.getElementById('playlists-grid');
  grid.innerHTML = '';

  // Find first fav track with cover for playlist card
  const all = getAllTracksArray();
  const firstFavWithCover = all.find(t => favorites.includes(t.id) && (t.img || coverCache[t.id]));

  const favCard = document.createElement('div');
  favCard.className = 'playlist-card';
  favCard.style.animationDelay = '0s';

  const favImgSrc = firstFavWithCover ? (firstFavWithCover.img || coverCache[firstFavWithCover.id]) : '';
  const favImgHtml = favImgSrc
    ? `<img src="${escapeHtml(favImgSrc)}" alt="" style="width:100%;height:100%;object-fit:cover">`
    : '<svg viewBox="0 0 24 24" style="fill:white;width:48px;height:48px"><path d="M20.84 4.61a5.5 5.5 0 00-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 00-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 000-7.78z"/></svg>';

  favCard.innerHTML = `
    <div class="playlist-card-img" style="background:linear-gradient(135deg,var(--accent),var(--accent2))">${favImgHtml}</div>
    <div class="playlist-card-info">
      <div class="playlist-card-name">Избранное</div>
      <div class="playlist-card-count">${favorites.length} трек${pluralize(favorites.length)}</div>
    </div>`;
  favCard.addEventListener('click', () => switchTab(2));
  grid.appendChild(favCard);

  playlists.forEach((pl, i) => {
    const card = document.createElement('div');
    card.className = 'playlist-card';
    card.style.animationDelay = (i + 1) * 0.08 + 's';

    // Find first track in playlist with cover
    const firstWithCover = pl.trackIds.map(id => all.find(t => t.id === id)).find(t => t && (t.img || coverCache[t.id]));
    const plImgSrc = firstWithCover ? (firstWithCover.img || coverCache[firstWithCover.id]) : '';
    const plImgHtml = plImgSrc
      ? `<img src="${escapeHtml(plImgSrc)}" alt="" style="width:100%;height:100%;object-fit:cover">`
      : '<svg viewBox="0 0 24 24" style="fill:rgba(255,255,255,0.5);width:40px;height:40px"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>';

    card.innerHTML = `
      <div class="playlist-card-img" style="background:hsl(${(i*60+200)%360},30%,20%)">${plImgHtml}</div>
      <div class="playlist-card-info">
        <div class="playlist-card-name">${escapeHtml(pl.name)}</div>
        <div class="playlist-card-count">${pl.trackIds.length} трек${pluralize(pl.trackIds.length)}</div>
      </div>`;
    card.addEventListener('click', () => openPlaylistView(pl.id));
    grid.appendChild(card);
  });

  const createCard = document.createElement('div');
  createCard.className = 'playlist-card playlist-create';
  createCard.style.animationDelay = (playlists.length + 1) * 0.08 + 's';
  createCard.innerHTML = `
    <div class="playlist-card-img">
      <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
    </div>
    <div class="playlist-card-info">
      <div class="playlist-card-name">Создать</div>
      <div class="playlist-card-count">Новый плейлист</div>
    </div>`;
  createCard.addEventListener('click', openCreatePlaylist);
  grid.appendChild(createCard);
}

function renderAll() {
  renderTracks('home');
  renderTracks('fav');
  renderTracks('dl');
  renderPlaylists();
  updateFavButtons();
}

function doSearch(ctx) { renderTracks(ctx); }

// ===================== PLAYER =====================
function playFromList(list, index) {
  if (index < 0 || index >= list.length) return;
  currentQueue = [...list];
  currentQueueIndex = index;
  loadAndPlay(currentQueue[currentQueueIndex]);
}

async function loadAndPlay(track) {
  currentTrack = track;
  let src = track.src;

  initAudioContext();
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

  if (!track.isLocal && downloaded.includes(track.id)) {
    try {
      const cached = await dbGet('audioCache', track.id);
      if (cached && cached.blob) src = URL.createObjectURL(cached.blob);
    } catch(e) {}
  }

  if (track.isLocal && (!src || src === '')) {
    try {
      const cached = await dbGet('audioCache', track.id);
      if (cached && cached.blob) { src = URL.createObjectURL(cached.blob); track.src = src; }
    } catch(e) {}
  }

  audio.src = src;
  audio.load();
  audio.play().then(() => { isPlaying = true; updatePlayButtons(); resumeEqAnimation(); }).catch(() => {});

  isPlaying = true;
  updatePlayButtons();
  updateMiniPlayer();
  updateFullPlayer();
  updateFavButtons();
  document.getElementById('mini-player').classList.add('show');
  resumeEqAnimation();

  document.querySelectorAll('.track-item').forEach(el => el.classList.remove('playing'));
}

function togglePlay(e) {
  if (e) e.stopPropagation();
  if (!currentTrack) return;
  if (isPlaying) { audio.pause(); isPlaying = false; stopEqAnimation(); }
  else {
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    audio.play().catch(() => {}); isPlaying = true; resumeEqAnimation();
  }
  updatePlayButtons();
}

function nextTrack() {
  if (!currentQueue.length) return;
  currentQueueIndex = isShuffle
    ? Math.floor(Math.random() * currentQueue.length)
    : (currentQueueIndex + 1) % currentQueue.length;
  loadAndPlay(currentQueue[currentQueueIndex]);
}

function prevTrack() {
  if (!currentQueue.length) return;
  if (audio.currentTime > 3) { audio.currentTime = 0; return; }
  currentQueueIndex = isShuffle
    ? Math.floor(Math.random() * currentQueue.length)
    : (currentQueueIndex - 1 + currentQueue.length) % currentQueue.length;
  loadAndPlay(currentQueue[currentQueueIndex]);
}

function toggleShuffle() {
  isShuffle = !isShuffle;
  document.getElementById('fp-shuffle').classList.toggle('active', isShuffle);
  showToast(isShuffle ? 'Перемешивание вкл' : 'Перемешивание выкл');
}

function toggleRepeat() {
  repeatMode = (repeatMode + 1) % 3;
  const btn = document.getElementById('fp-repeat');
  btn.classList.toggle('active', repeatMode > 0);
  btn.innerHTML = repeatMode === 2
    ? '<svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg><span style="position:absolute;font-size:8px;font-weight:bold;color:var(--accent)">1</span>'
    : '<svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>';
  if (repeatMode === 2) btn.style.position = 'relative';
  showToast(['Повтор выкл', 'Повтор всех', 'Повтор одного'][repeatMode]);
}

audio.addEventListener('ended', () => {
  if (repeatMode === 2) { audio.currentTime = 0; audio.play(); }
  else if (repeatMode === 1 || currentQueueIndex < currentQueue.length - 1) nextTrack();
  else { isPlaying = false; updatePlayButtons(); stopEqAnimation(); }
});

audio.addEventListener('timeupdate', () => {
  if (!audio.duration) return;
  const pct = (audio.currentTime / audio.duration) * 100;
  document.getElementById('mini-progress').style.width = pct + '%';
  document.getElementById('fp-progress-fill').style.width = pct + '%';
  document.getElementById('fp-current-time').textContent = formatTime(audio.currentTime);
  document.getElementById('fp-duration').textContent = formatTime(audio.duration);
});

let isDraggingProgress = false;

function handleProgressSeek(clientX) {
  const bar = document.getElementById('fp-progress-bar');
  const rect = bar.getBoundingClientRect();
  const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
  if (audio.duration) {
    audio.currentTime = pct * audio.duration;
    document.getElementById('fp-progress-fill').style.width = (pct * 100) + '%';
  }
}

function seekTrack(e) { handleProgressSeek(e.clientX); }

const fpBar = document.getElementById('fp-progress-bar');
fpBar.addEventListener('click', seekTrack);
fpBar.addEventListener('touchstart', (e) => {
  isDraggingProgress = true;
  fpBar.classList.add('dragging');
  handleProgressSeek(e.touches[0].clientX);
}, { passive: true });
fpBar.addEventListener('touchmove', (e) => {
  if (isDraggingProgress) handleProgressSeek(e.touches[0].clientX);
}, { passive: true });
fpBar.addEventListener('touchend', () => {
  isDraggingProgress = false;
  fpBar.classList.remove('dragging');
}, { passive: true });

function updatePlayButtons() {
  const play = '<path d="M8 5v14l11-7z"/>';
  const pause = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
  document.getElementById('mini-play-icon').innerHTML = isPlaying ? pause : play;
  document.getElementById('fp-play-icon').innerHTML = isPlaying ? pause : play;
}

function getImgHtml(track, size) {
  const src = track.img || coverCache[track.id] || '';
  const musicIcon = size === 'large'
    ? '<svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>'
    : '<svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>';
  if (src) {
    return `<img src="${escapeHtml(src)}" alt="" onerror="this.style.display='none';this.parentElement.querySelector('svg').style.display='block'">${musicIcon.replace('viewBox', 'style="display:none" viewBox')}`;
  }
  return musicIcon;
}

function updateMiniPlayer() {
  if (!currentTrack) return;
  document.getElementById('mini-name').textContent = currentTrack.name;
  document.getElementById('mini-artist').textContent = currentTrack.artist;
  document.getElementById('mini-img-wrap').innerHTML = getImgHtml(currentTrack, 'small');
}

function updateFullPlayer() {
  if (!currentTrack) return;
  document.getElementById('fp-name').textContent = currentTrack.name;
  document.getElementById('fp-artist').textContent = currentTrack.artist;
  document.getElementById('fp-img-wrap').innerHTML = getImgHtml(currentTrack, 'large');

  const isDl = downloaded.includes(currentTrack.id) || currentTrack.isLocal;
  document.getElementById('fp-download-btn').classList.toggle('downloaded', isDl);
  document.getElementById('fp-download-text').textContent = isDl ? 'Скачано' : 'Скачать';
}

function updateFavButtons() {
  if (!currentTrack) return;
  const isFav = favorites.includes(currentTrack.id);
  document.getElementById('mini-fav-btn').classList.toggle('liked', isFav);
  document.getElementById('fp-like-btn').classList.toggle('liked', isFav);
}

// ===================== FULL PLAYER GESTURES =====================
function openFullPlayer(e) {
  if (e && (e.target.closest('.mini-play-btn') || e.target.closest('.mini-fav'))) return;
  document.getElementById('full-player').classList.add('show');
  updateFullPlayer();
  updateFavButtons();
}

function closeFullPlayer() {
  document.getElementById('full-player').classList.remove('show');
}

let fpSwipeStartX = 0, fpSwipeStartY = 0, fpSwiping = false;
const fpEl = document.getElementById('full-player');

fpEl.addEventListener('touchstart', (e) => {
  if (isDraggingProgress) return;
  fpSwipeStartX = e.touches[0].clientX;
  fpSwipeStartY = e.touches[0].clientY;
  fpSwiping = false;
}, { passive: true });

fpEl.addEventListener('touchmove', (e) => {
  if (isDraggingProgress) return;
  const dx = Math.abs(e.touches[0].clientX - fpSwipeStartX);
  const dy = Math.abs(e.touches[0].clientY - fpSwipeStartY);
  if (dx > dy && dx > 15) fpSwiping = true;
}, { passive: true });

fpEl.addEventListener('touchend', (e) => {
  if (isDraggingProgress) return;
  if (!fpSwiping) return;
  const dx = e.changedTouches[0].clientX - fpSwipeStartX;
  if (Math.abs(dx) > 80) { dx < 0 ? nextTrack() : prevTrack(); }
}, { passive: true });

let fpBarStartY = 0;
document.querySelector('.fp-close').addEventListener('touchstart', (e) => {
  fpBarStartY = e.touches[0].clientY;
}, { passive: true });
document.querySelector('.fp-close').addEventListener('touchend', (e) => {
  if (e.changedTouches[0].clientY - fpBarStartY > 50) closeFullPlayer();
});

let mpSwipeStartX = 0;
const mpEl = document.getElementById('mini-player');
mpEl.addEventListener('touchstart', (e) => { mpSwipeStartX = e.touches[0].clientX; }, { passive: true });
mpEl.addEventListener('touchend', (e) => {
  const dx = e.changedTouches[0].clientX - mpSwipeStartX;
  if (Math.abs(dx) > 80) { e.preventDefault(); dx < 0 ? nextTrack() : prevTrack(); }
});

// ===================== FAVORITES =====================
function toggleFavorite(trackId) {
  const idx = favorites.indexOf(trackId);
  if (idx >= 0) { favorites.splice(idx, 1); showToast('Убрано из избранного'); }
  else { favorites.push(trackId); showToast('Добавлено в избранное'); }
  saveAppState();
  renderAll();
  updateFavButtons();
  if (currentPlaylistViewId) renderPlaylistTracks();
}

function toggleCurrentFav(e) {
  if (e) e.stopPropagation();
  if (!currentTrack) return;
  toggleFavorite(currentTrack.id);
}

// ===================== DOWNLOADS =====================
async function downloadCurrentTrack() {
  if (!currentTrack) return;
  if (downloaded.includes(currentTrack.id) || currentTrack.isLocal) {
    showToast('Уже скачано');
    return;
  }
  showToast('Скачивание...');
  try {
    const resp = await fetch(currentTrack.src);
    const blob = await resp.blob();
    await dbPut('audioCache', { id: currentTrack.id, blob });
    downloaded.push(currentTrack.id);

    // Also save cover if present
    if (currentTrack.img && currentTrack.img.startsWith('blob:')) {
      try {
        const coverResp = await fetch(currentTrack.img);
        const coverBlob = await coverResp.blob();
        await saveCover(currentTrack.id, coverBlob);
      } catch(e) {}
    }

    await saveAppState();
    updateFullPlayer();
    renderTracks('dl');
    showToast('Скачано');
  } catch (e) {
    showToast('Ошибка скачивания');
  }
}

// ===================== PLAYLISTS =====================
function openCreatePlaylist() {
  document.getElementById('create-playlist-modal').classList.add('show');
  setTimeout(() => document.getElementById('cpm-input').focus(), 100);
}

function closeCreatePlaylist() {
  document.getElementById('create-playlist-modal').classList.remove('show');
  document.getElementById('cpm-input').value = '';
}

function createPlaylist() {
  const name = document.getElementById('cpm-input').value.trim();
  if (!name) { showToast('Введите название'); return; }
  playlists.push({ id: 'pl_' + Date.now(), name, trackIds: [] });
  saveAppState();
  closeCreatePlaylist();
  renderPlaylists();
  showToast('Плейлист создан');
}

function openPlaylistView(plId) {
  currentPlaylistViewId = plId;
  const pl = playlists.find(p => p.id === plId);
  if (!pl) return;
  document.getElementById('pv-title').textContent = pl.name;
  renderPlaylistTracks();
  document.getElementById('playlist-view').classList.add('show');
}

function closePlaylistView() {
  document.getElementById('playlist-view').classList.remove('show');
  currentPlaylistViewId = null;
}

function renderPlaylistTracks() {
  const pl = playlists.find(p => p.id === currentPlaylistViewId);
  if (!pl) return;
  const container = document.getElementById('pv-tracks');
  container.innerHTML = '';
  const all = getAllTracksArray();
  const tracks = pl.trackIds.map(id => all.find(t => t.id === id)).filter(Boolean);

  if (!tracks.length) {
    container.innerHTML = '<div class="empty-state"><svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>Нет треков</p></div>';
    return;
  }
  tracks.forEach((t, i) => {
    const item = renderTrackItem(t, i, 'playlist');
    const handler = () => playFromList(tracks, i);
    item.querySelector('.track-info').onclick = handler;
    item.querySelector('.track-img').onclick = handler;
    container.appendChild(item);
  });
}

function deletePlaylist() {
  if (!currentPlaylistViewId) return;
  playlists = playlists.filter(p => p.id !== currentPlaylistViewId);
  saveAppState();
  closePlaylistView();
  renderPlaylists();
  showToast('Плейлист удален');
}

function addTracksToPlaylist(mode) {
  addTracksMode = mode;
  selectedAddTracks = new Set();
  document.getElementById('atm-title').textContent = mode === 'fav' ? 'Из избранного' : 'Добавить треки';
  document.getElementById('search-add-tracks').value = '';
  renderAddTracksList();
  document.getElementById('add-tracks-modal').classList.add('show');
}

function renderAddTracksList() {
  const container = document.getElementById('atm-tracks-list');
  container.innerHTML = '';
  const pl = playlists.find(p => p.id === currentPlaylistViewId);
  if (!pl) return;

  const all = getAllTracksArray();
  let tracks = addTracksMode === 'fav'
    ? all.filter(t => favorites.includes(t.id) && !pl.trackIds.includes(t.id))
    : all.filter(t => !pl.trackIds.includes(t.id));

  tracks = filterTracks(tracks, document.getElementById('search-add-tracks').value);

  if (!tracks.length) {
    container.innerHTML = '<div class="empty-state"><p>Нет доступных треков</p></div>';
    return;
  }

  tracks.forEach(t => {
    const imgSrc = t.img || coverCache[t.id] || '';
    const imgHtml = imgSrc
      ? `<img src="${escapeHtml(imgSrc)}" alt="" loading="lazy" style="width:100%;height:100%;object-fit:cover;display:block">`
      : MUSIC_SVG;

    const div = document.createElement('div');
    div.className = 'track-item-selectable';
    div.innerHTML = `
      <div class="select-check ${selectedAddTracks.has(t.id) ? 'checked' : ''}">
        <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
      </div>
      <div class="track-img">${imgHtml}</div>
      <div class="track-info">
        <div class="track-name">${escapeHtml(t.name)}</div>
        <div class="track-artist">${escapeHtml(t.artist)}</div>
      </div>`;
    div.addEventListener('click', () => {
      if (selectedAddTracks.has(t.id)) selectedAddTracks.delete(t.id);
      else selectedAddTracks.add(t.id);
      div.querySelector('.select-check').classList.toggle('checked');
    });
    container.appendChild(div);
  });
}

function searchAddTracks() { renderAddTracksList(); }

function closeAddTracksModal() {
  document.getElementById('add-tracks-modal').classList.remove('show');
  document.getElementById('search-add-tracks').value = '';
}

function doneAddTracks() {
  const pl = playlists.find(p => p.id === currentPlaylistViewId);
  if (!pl) return;
  selectedAddTracks.forEach(id => { if (!pl.trackIds.includes(id)) pl.trackIds.push(id); });
  saveAppState();
  closeAddTracksModal();
  renderPlaylistTracks();
  showToast(`Добавлено ${selectedAddTracks.size} трек${pluralize(selectedAddTracks.size)}`);
}

// ===================== FILE UPLOAD =====================
function uploadLocalTracks() { document.getElementById('file-input').click(); }

async function handleFileUpload(e) {
  const files = Array.from(e.target.files);
  if (!files.length) return;
  showToast('Обработка файлов...');

  for (const file of files) {
    const id = 'local_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
    let artist = 'Мои треки', name = file.name.replace(/\.[^.]+$/, '');
    let coverUrl = '';

    try {
      const tags = await readID3FromBlob(file);
      if (tags) {
        if (tags.title) name = tags.title;
        if (tags.artist) artist = tags.artist;
        if (tags.coverBlob) {
          coverUrl = URL.createObjectURL(tags.coverBlob);
          coverCache[id] = coverUrl;
          await saveCover(id, tags.coverBlob);
        }
      } else {
        const nameNoExt = file.name.replace(/\.[^.]+$/, '');
        const parts = nameNoExt.split(' - ');
        if (parts.length >= 2) { artist = parts[0].trim(); name = parts.slice(1).join(' - ').trim(); }
      }
    } catch(err) {
      const nameNoExt = file.name.replace(/\.[^.]+$/, '');
      const parts = nameNoExt.split(' - ');
      if (parts.length >= 2) { artist = parts[0].trim(); name = parts.slice(1).join(' - ').trim(); }
    }

    await dbPut('audioCache', { id, blob: file });
    localTracks.push({ id, name, artist, album: '', src: URL.createObjectURL(file), img: coverUrl, isLocal: true });
    downloaded.push(id);
  }
  await saveAppState();
  renderAll();
  showToast(`Добавлено ${files.length} трек${pluralize(files.length)}`);
  e.target.value = '';
}

// ===================== TABS =====================
function switchTab(index) {
  currentTab = index;
  document.getElementById('tabs-wrapper').style.transform = `translateX(-${index * 25}%)`;
  document.querySelectorAll('.nav-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.tab) === index);
  });
  switch (index) {
    case 0: renderTracks('home'); break;
    case 1: renderPlaylists(); break;
    case 2: renderTracks('fav'); break;
    case 3: renderTracks('dl'); break;
  }
  saveAppState();
}

let tStartX = 0, tStartY = 0, tSwiping = false, tMoving = false;
const tabsContainer = document.getElementById('tabs-container');
const tabsWrapper = document.getElementById('tabs-wrapper');

tabsContainer.addEventListener('touchstart', (e) => {
  tStartX = e.touches[0].clientX;
  tStartY = e.touches[0].clientY;
  tSwiping = false; tMoving = false;
}, { passive: true });

tabsContainer.addEventListener('touchmove', (e) => {
  const dx = e.touches[0].clientX - tStartX;
  const dy = e.touches[0].clientY - tStartY;
  if (!tMoving && Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 10) {
    tSwiping = true; tMoving = true;
    tabsWrapper.style.transition = 'none';
  }
  if (tSwiping) {
    const base = -currentTab * 25;
    const offset = (dx / tabsContainer.offsetWidth) * 25;
    let target = base + offset;
    if (target > 0) target *= 0.3;
    if (target < -75) target = -75 + (target + 75) * 0.3;
    tabsWrapper.style.transform = `translateX(${target}%)`;
  }
}, { passive: true });

tabsContainer.addEventListener('touchend', (e) => {
  tabsWrapper.style.transition = '';
  if (!tSwiping) return;
  const dx = e.changedTouches[0].clientX - tStartX;
  if (Math.abs(dx) > 50) {
    if (dx < 0 && currentTab < 3) switchTab(currentTab + 1);
    else if (dx > 0 && currentTab > 0) switchTab(currentTab - 1);
    else switchTab(currentTab);
  } else {
    switchTab(currentTab);
  }
}, { passive: true });

// ===================== SPLASH =====================
function enterApp() {
  const splash = document.getElementById('splash');
  splash.classList.add('hide');
  setTimeout(() => {
    splash.style.display = 'none';
    document.getElementById('app').classList.add('show');
    switchTab(currentTab);
  }, 600);
  saveAppState();
}

// ===================== ONLINE/OFFLINE =====================
function updateOnlineStatus() {
  const dot = document.getElementById('splash-status-dot');
  const text = document.getElementById('splash-status-text');
  if (navigator.onLine) { dot.classList.remove('offline'); text.textContent = 'Онлайн'; }
  else { dot.classList.add('offline'); text.textContent = 'Офлайн'; }
}

window.addEventListener('online', async () => {
  updateOnlineStatus();
  showToast('Подключение восстановлено');
  const ghTracks = await loadTracksFromGithub();
  if (ghTracks.length) { allTracks = ghTracks; await saveAppState(); renderAll(); }
});

window.addEventListener('offline', () => {
  updateOnlineStatus();
  showToast('Офлайн режим');
  renderAll();
});

// ===================== INIT =====================
async function init() {
  await openDB();
  await loadAppState();
  updateOnlineStatus();

  if (navigator.onLine) {
    allTracks = await loadTracksFromGithub();
    if (allTracks.length) await saveAppState();
  } else {
    allTracks = await getCachedTracks();
  }

  if (!isFirstVisit) {
    document.getElementById('splash').style.display = 'none';
    document.getElementById('app').classList.add('show');
    switchTab(currentTab);
  }

  renderAll();
}

init();
</script>
</body>
</html>